https://1drv.ms/p/c/69187d6452360368/IQAN3DJvPSNMT7sQb_8OJovIARu9tyUNJ6jluG3ft0LOI3Y?e=OAPpcp

pip install numpy matplotlib scikit-image scipy

import json
import numpy as np
import matplotlib.pyplot as plt

from skimage import io, color, filters, morphology
from scipy.spatial.distance import euclidean

# ==============================
# INPUT
# ==============================
IMAGE_PATH = "input_crop.png"   # <-- your cropped PNG/JPG
OUTPUT_JSON = "vectorized_output.json"

# ==============================
# 1. LOAD + BINARIZE IMAGE
# ==============================
img = io.imread(IMAGE_PATH)

if img.ndim == 3:
    img_gray = color.rgb2gray(img)
else:
    img_gray = img.astype(float) / 255.0

thresh = filters.threshold_otsu(img_gray)
binary = img_gray < thresh

# ==============================
# 2. SKELETONIZATION
# ==============================
skeleton = morphology.skeletonize(binary)

# ==============================
# 3. TRACE EXTRACTION
# ==============================
def neighbors(p):
    x, y = p
    return [(x+i, y+j) for i in [-1,0,1] for j in [-1,0,1]
            if not (i==0 and j==0)]

def valid(p, skel):
    x, y = p
    return 0 <= x < skel.shape[0] and 0 <= y < skel.shape[1] and skel[x,y]

visited = set()
traces = []

for x in range(skeleton.shape[0]):
    for y in range(skeleton.shape[1]):
        if skeleton[x,y] and (x,y) not in visited:
            trace = [(x,y)]
            visited.add((x,y))
            cur = (x,y)

            while True:
                nbrs = [p for p in neighbors(cur)
                        if valid(p, skeleton) and p not in visited]
                if len(nbrs) != 1:
                    break
                cur = nbrs[0]
                trace.append(cur)
                visited.add(cur)

            traces.append(trace)

# ==============================
# 4. REMOVE SMALL TRACES
# ==============================
traces = [t for t in traces if len(t) >= 4]

# ==============================
# 5. CUBIC BEZIER FITTING
# ==============================
def fit_cubic_bezier(points):
    points = np.array(points)
    m = len(points)
    t = np.linspace(0, 1, m)

    B = np.column_stack([
        (1 - t)**3,
        3*t*(1 - t)**2,
        3*(t**2)*(1 - t),
        t**3
    ])

    P0 = points[0]
    P3 = points[-1]

    B_mid = B[:, 1:3]
    rhs = points - np.outer(B[:,0], P0) - np.outer(B[:,3], P3)

    ctrl_mid, _, _, _ = np.linalg.lstsq(B_mid, rhs, rcond=None)
    P1, P2 = ctrl_mid

    return np.vstack([P0, P1, P2, P3])

beziers = [fit_cubic_bezier(t) for t in traces]

# ==============================
# 6. FEATURE EXTRACTION
# ==============================
features = []

for bz in beziers:
    length = sum(euclidean(bz[i], bz[i+1]) for i in range(3))
    direction = (bz[-1] - bz[0]).tolist()
    curvature_proxy = euclidean(bz[1], bz[2])

    features.append({
        "length": float(length),
        "direction": direction,
        "curvature_proxy": float(curvature_proxy)
    })

# ==============================
# 7. VISUALIZATION
# ==============================
plt.figure(figsize=(6,6))
plt.imshow(img_gray, cmap="gray")
for bz in beziers:
    bz = np.array(bz)
    plt.plot(bz[:,1], bz[:,0], 'r')
plt.title("Vectorized Cubic Bezier Curves")
plt.axis("off")
plt.show()

# ==============================
# 8. SAVE JSON
# ==============================
output = {
    "num_components": len(beziers),
    "components": [
        {
            "control_points": bz.tolist(),
            "features": feat
        }
        for bz, feat in zip(beziers, features)
    ]
}

with open(OUTPUT_JSON, "w") as f:
    json.dump(output, f, indent=2)

print(f"Vectorization complete. Saved to {OUTPUT_JSON}")
