https://1drv.ms/p/c/69187d6452360368/IQAN3DJvPSNMT7sQb_8OJovIARu9tyUNJ6jluG3ft0LOI3Y?e=OAPpcp

pip install numpy matplotlib scikit-image scipy

import json
import numpy as np
import matplotlib.pyplot as plt

from skimage import io, color, filters, morphology
from scipy.spatial.distance import euclidean

# ======================
# INPUT
# ======================
IMAGE_PATH = "input_crop.png"
OUTPUT_JSON = "vectorized_output.json"

# ======================
# 1. LOAD & BINARIZE
# ======================
img = io.imread(IMAGE_PATH)
if img.ndim == 3:
    img_gray = color.rgb2gray(img)
else:
    img_gray = img.astype(float) / 255.0

binary = img_gray < filters.threshold_otsu(img_gray)

# ======================
# 2. SKELETONIZATION
# ======================
skel = morphology.skeletonize(binary)

# ======================
# 3. PIXEL DEGREE CLASSIFICATION
# ======================
def neighbors(p):
    x, y = p
    return [(x+i, y+j) for i in [-1,0,1] for j in [-1,0,1]
            if not (i==0 and j==0)]

def valid(p):
    x, y = p
    return 0 <= x < skel.shape[0] and 0 <= y < skel.shape[1] and skel[x,y]

pixel_degree = {}
pixels = np.argwhere(skel)

for x, y in pixels:
    count = sum(valid(p) for p in neighbors((x,y)))
    pixel_degree[(x,y)] = count

endpoints = {p for p,d in pixel_degree.items() if d == 1}
junctions = {p for p,d in pixel_degree.items() if d >= 3}

# ======================
# 4. TRACE EXTRACTION (endpoint â†” junction)
# ======================
visited = set()
traces = []

def walk_trace(start):
    trace = [start]
    visited.add(start)
    cur = start

    while True:
        nbrs = [p for p in neighbors(cur)
                if valid(p) and p not in visited]
        if len(nbrs) != 1:
            break
        nxt = nbrs[0]
        trace.append(nxt)
        visited.add(nxt)
        cur = nxt
        if cur in junctions:
            break
    return trace

for p in endpoints.union(junctions):
    if p not in visited:
        tr = walk_trace(p)
        if len(tr) >= 2:
            traces.append(tr)

# ======================
# 5. CORNER DETECTION & SPLITTING
# ======================
def split_at_corners(trace):
    if len(trace) < 6:
        return [trace]

    pts = np.array(trace)
    angles = []

    for i in range(1, len(pts)-1):
        v1 = pts[i-1] - pts[i]
        v2 = pts[i+1] - pts[i]
        cosang = np.dot(v1, v2) / (np.linalg.norm(v1)*np.linalg.norm(v2) + 1e-6)
        angles.append(np.arccos(np.clip(cosang, -1, 1)))

    angles = np.array(angles)
    second_deriv = np.diff(angles, n=2)

    splits = np.where(second_deriv > 0.5)[0] + 2
    if len(splits) == 0:
        return [trace]

    pieces = []
    prev = 0
    for s in splits:
        pieces.append(trace[prev:s])
        prev = s
    pieces.append(trace[prev:])

    return [p for p in pieces if len(p) >= 4]

final_traces = []
for t in traces:
    final_traces.extend(split_at_corners(t))

# ======================
# 6. CUBIC BEZIER FITTING
# ======================
def fit_bezier(trace):
    pts = np.array(trace)
    d = np.cumsum([0] + [euclidean(pts[i], pts[i-1]) for i in range(1,len(pts))])
    t = d / d[-1]

    B = np.column_stack([
        (1-t)**3,
        3*t*(1-t)**2,
        3*t**2*(1-t),
        t**3
    ])

    P0, P3 = pts[0], pts[-1]
    rhs = pts - np.outer(B[:,0],P0) - np.outer(B[:,3],P3)
    ctrl, *_ = np.linalg.lstsq(B[:,1:3], rhs, rcond=None)

    return np.vstack([P0, ctrl[0], ctrl[1], P3])

beziers = [fit_bezier(t) for t in final_traces]

# ======================
# 7. FEATURE LABELS
# ======================
components = []
for bz in beziers:
    length = sum(euclidean(bz[i], bz[i+1]) for i in range(3))
    curvature = euclidean(bz[1], bz[2])

    geom_type = "line" if curvature < 2 else "curve"

    components.append({
        "control_points": bz.tolist(),
        "length": float(length),
        "curvature": float(curvature),
        "type": geom_type
    })

# ======================
# 8. VISUALIZATION
# ======================
plt.figure(figsize=(6,6))
plt.imshow(img_gray, cmap="gray")
for bz in beziers:
    bz = np.array(bz)
    plt.plot(bz[:,1], bz[:,0], 'r')
plt.title("Proper Vectorization (Section 3.1)")
plt.axis("off")
plt.show()

# ======================
# 9. SAVE JSON
# ======================
with open(OUTPUT_JSON, "w") as f:
    json.dump({"components": components}, f, indent=2)

print("Vectorization complete.")
